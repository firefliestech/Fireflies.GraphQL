using System.Text.Json.Nodes;
using Fireflies.GraphQL.Client.Generator.Schema;
using GraphQLParser.AST;
using GraphQLParser.Visitors;
using System.Reflection;
using Fireflies.GraphQL.Client.Generator.Builders;

namespace Fireflies.GraphQL.Client.Generator;

public class ClientGenerator : ASTVisitor<GraphQLGeneratorContext> {
    private readonly string _clientName;
    private readonly ClientSettings _clientSettings;
    private readonly IEnumerable<GraphQLDocument> _graphQLDocuments;

    private readonly GraphQLRootGeneratorContext _rootContext;

    public ClientGenerator(string clientName, JsonNode schema, ClientSettings clientSettings, IEnumerable<GraphQLDocument> graphQLDocuments) {
        _clientName = clientName;
        _clientSettings = clientSettings;
        _graphQLDocuments = graphQLDocuments;
        _rootContext = new GraphQLRootGeneratorContext(schema);
    }

    public string Source => _rootContext.Source;

    public async Task Generate() {
        var typeBuilder = _rootContext.GetRawTypeBuilder();
        typeBuilder.AppendLine("// <auto-generated/>");
        typeBuilder.AppendLine($"// <generated-at=\"{DateTimeOffset.UtcNow.ToString("yyyy-MM-dd'T'HH:mm:ss.fffzzz")}\"/>");
        typeBuilder.AppendLine("#nullable enable");
        typeBuilder.AppendLine();
        typeBuilder.AppendLine("using System.Text;");
        typeBuilder.AppendLine("using System.Text.Json;");
        typeBuilder.AppendLine("using System.Text.Json.Nodes;");
        typeBuilder.AppendLine("using System.Text.Json.Serialization;");
        typeBuilder.AppendLine();

        if(!string.IsNullOrWhiteSpace(_clientSettings.Namespace)) {
            typeBuilder.AppendLine($"namespace {_clientSettings.Namespace}.{_clientName};");
            typeBuilder.AppendLine();
        }

        GenerateTypes();

        typeBuilder.AppendLine(await GetResource("Fireflies.GraphQL.Client.Generator.Error.ClientError.cs"));
        typeBuilder.AppendLine();
        typeBuilder.AppendLine(await GetResource("Fireflies.GraphQL.Client.Generator.Error.IClientError.cs"));
        typeBuilder.AppendLine();
        typeBuilder.AppendLine(await GetResource("Fireflies.GraphQL.Client.Generator.Error.Location.cs"));
        typeBuilder.AppendLine();

        var clientBuilder = _rootContext.GetClientBuilder(_clientName);

        foreach(var graphqlDocument in _graphQLDocuments) {
            var context = new GraphQLGeneratorContext(_rootContext, graphqlDocument, new FragmentAccessor(graphqlDocument));

            foreach(var fragmentDefinition in graphqlDocument.Definitions.OfType<GraphQLFragmentDefinition>()) {
                var schemaType = context.GetSchemaType(fragmentDefinition.TypeCondition.Type);
                var fragmentName = fragmentDefinition.FragmentName.Name.StringValue;
                var subResultTypeBuilder = new SubResultTypeBuilder(fragmentName, fragmentDefinition, null, schemaType, context);
                subResultTypeBuilder.OnlyInterface();
                await subResultTypeBuilder.Build();

                foreach(var subSchemaType in schemaType.PossibleTypes.Select(x => x.GetOfType(context))) {
                    var subTypeName = $"{fragmentName}_{subSchemaType.Name.Capitalize()}";
                    var subFragmentBuilder = new SubResultTypeBuilder(subTypeName, fragmentDefinition, schemaType, subSchemaType, context);
                    subFragmentBuilder.AddInterfaceImplementation($"I{fragmentName}");
                    subFragmentBuilder.OnlyInterface();
                    subFragmentBuilder.ExactTypeConditionRequired();
                    await subFragmentBuilder.Build();
                }
            }

            foreach(var operationDefinition in graphqlDocument.Definitions.OfType<GraphQLOperationDefinition>()) {
                await clientBuilder.AddOperation(operationDefinition, context);
            }
        }

        await clientBuilder.Build();
    }

    private void GenerateTypes() {
        foreach(var schemaType in _rootContext.SchemaTypes.Values) {
            switch(schemaType.Kind) {
                case SchemaTypeKind.ENUM:
                    GenerateEnum(schemaType);
                    break;
                case SchemaTypeKind.INPUT_OBJECT:
                    GenerateInputObject(schemaType);
                    break;
            }
        }
    }

    private string? GenerateInputObject(SchemaType schemaType) {
        var className = schemaType.Name;

        if(!_rootContext.ShouldGenerateType(className))
            return className;

        var typeBuilder = _rootContext.GetRawTypeBuilder();
        typeBuilder.AppendLine($"public class {className} {{");

        foreach(var field in schemaType.InputFields.Select(x => new { x.Type, x.Name}).Union(schemaType.Fields.Select(x => new { Type = x.Type, x.Name }))) {
            var fieldType = field.Type.GetOfType(_rootContext);
            if(fieldType.Kind is SchemaTypeKind.SCALAR or SchemaTypeKind.ENUM) {
                typeBuilder.AppendLine($"\tpublic {field.Type.GetNetType()} {field.Name.Capitalize()} {{ get; set; }}");
            } else {
                var subType = GenerateInputObject(schemaType);
                typeBuilder.AppendLine($"\tpublic {subType} {field.Name.Capitalize()} {{ get; set; }}");
            }
        }

        typeBuilder.AppendLine("}");

        return className;
    }

    private void GenerateEnum(SchemaType schemaType) {
        var typeBuilder = _rootContext.GetRawTypeBuilder();
        typeBuilder.AppendLine($"public enum {schemaType.Name} {{");
        foreach(var value in schemaType.EnumValues) {
            if(value.IsDeprecated)
                typeBuilder.AppendLine($"\t[{nameof(ObsoleteAttribute)}{(value.DeprecationReason != null ? $"({value.DeprecationReason})" : null)}]");
            typeBuilder.AppendLine($"\t{value.Name},");
        }

        typeBuilder.AppendLine("}");
    }

    private static async Task<string> GetResource(string resourceName) {
        var assembly = Assembly.GetExecutingAssembly();
        await using var stream = assembly.GetManifestResourceStream(resourceName);
        using var reader = new StreamReader(stream!);
        return await reader.ReadToEndAsync();
    }
}