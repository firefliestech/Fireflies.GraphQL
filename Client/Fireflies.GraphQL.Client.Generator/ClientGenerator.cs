using System.Text.Json.Nodes;
using Fireflies.GraphQL.Client.Generator.Schema;
using GraphQLParser.AST;
using GraphQLParser.Visitors;

namespace Fireflies.GraphQL.Client.Generator;

public class ClientGenerator : ASTVisitor<GraphQLGeneratorContext> {
    private readonly string _clientName;
    private readonly GeneratorSettings _generatorSettings;
    private readonly IEnumerable<GraphQLDocument> _graphQLDocuments;

    private readonly GraphQLRootGeneratorContext _rootContext;

    public ClientGenerator(string clientName, JsonNode schema, GeneratorSettings generatorSettings, IEnumerable<GraphQLDocument> graphQLDocuments) {
        _clientName = clientName;
        _generatorSettings = generatorSettings;
        _graphQLDocuments = graphQLDocuments;
        _rootContext = new GraphQLRootGeneratorContext(schema);
    }

    public string Source => _rootContext.Source;

    public async Task Generate() {
        var typeBuilder = _rootContext.GetRawTypeBuilder();
        typeBuilder.AppendLine("// <auto-generated/>");
        typeBuilder.AppendLine("#nullable enable");
        typeBuilder.AppendLine();
        typeBuilder.AppendLine("using System.Text;");
        typeBuilder.AppendLine("using System.Text.Json;");
        typeBuilder.AppendLine("using System.Text.Json.Nodes;");
        typeBuilder.AppendLine("using System.Text.Json.Serialization;");

        typeBuilder.AppendLine();

        typeBuilder.AppendLine($"namespace {_generatorSettings.Namespace}.{_clientName};");
        typeBuilder.AppendLine();

        GenerateTypes();

        var clientBuilder = _rootContext.GetClientBuilder(_clientName);

        foreach(var graphqlDocument in _graphQLDocuments) {
            var context = new GraphQLGeneratorContext(_rootContext, graphqlDocument, new FragmentAccessor(graphqlDocument));

            foreach(var operationDefinition in graphqlDocument.Definitions.OfType<GraphQLOperationDefinition>()) {
                await clientBuilder.AddOperation(operationDefinition, context);
            }
        }

        await clientBuilder.Build();
    }

    private void GenerateTypes() {
        foreach(var schemaType in _rootContext.SchemaTypes.Values) {
            switch(schemaType.Kind) {
                case SchemaTypeKind.ENUM:
                    GenerateEnum(schemaType);
                    break;
                case SchemaTypeKind.INPUT_OBJECT:
                    GenerateInputObject(schemaType);
                    break;
            }
        }
    }

    private string? GenerateInputObject(SchemaType schemaType) {
        var className = schemaType.Name;

        if(!_rootContext.ShouldGenerateType(className))
            return className;

        var typeBuilder = _rootContext.GetRawTypeBuilder();
        typeBuilder.AppendLine($"public class {className} {{");

        foreach(var field in schemaType.InputFields.Select(x => new { x.Type, x.Name }).Union(schemaType.Fields.Select(x => new { Type = x.Type, x.Name }))) {
            var fieldType = field.Type.GetOfType(_rootContext);
            if(fieldType.Kind is SchemaTypeKind.SCALAR or SchemaTypeKind.ENUM) {
                typeBuilder.AppendLine($"\tpublic {field.Type.GetNetType()} {field.Name.Capitalize()} {{ get; set; }}");
            } else {
                var subType = GenerateInputObject(schemaType);
                typeBuilder.AppendLine($"\tpublic {subType} {field.Name.Capitalize()} {{ get; set; }}");
            }
        }

        typeBuilder.AppendLine("}");

        return className;
    }

    private void GenerateEnum(SchemaType schemaType) {
        var typeBuilder = _rootContext.GetRawTypeBuilder();
        typeBuilder.AppendLine($"public enum {schemaType.Name} {{");
        foreach(var value in schemaType.EnumValues) {
            if(value.IsDeprecated)
                typeBuilder.AppendLine($"\t[{nameof(ObsoleteAttribute)}{(value.DeprecationReason != null ? $"({value.DeprecationReason})" : null)}]");
            typeBuilder.AppendLine($"\t{value.Name},");
        }

        typeBuilder.AppendLine("}");
    }
}